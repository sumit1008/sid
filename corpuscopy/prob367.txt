D1. DFS Checker (Easy Version)
This is the easy version of the problem. In this version, the given tree is a perfect binary tree and the constraints on nğ‘› and qğ‘ are lower. You can make hacks only if both versions of the problem are solved.
You are given a perfect binary treeâ€ â€  consisting of nğ‘› vertices. The vertices are numbered from 11 to nğ‘›, and the root is the vertex 11. You are also given a permutation p1,p2,â€¦,pnğ‘1,ğ‘2,â€¦,ğ‘ğ‘› of [1,2,â€¦,n][1,2,â€¦,ğ‘›].
You need to answer qğ‘ queries. For each query, you are given two integers xğ‘¥, yğ‘¦; you need to swap pxğ‘ğ‘¥ and pyğ‘ğ‘¦ and determine if p1,p2,â€¦,pnğ‘1,ğ‘2,â€¦,ğ‘ğ‘› is a valid DFS orderâ€¡â€¡ of the given tree.
Please note that the swaps are persistent through queries.
â€ â€  A perfect binary tree is a tree with vertex 11 as its root, with size n=2kâˆ’1ğ‘›=2ğ‘˜âˆ’1 for a positive integer kğ‘˜, and where the parent of each vertex iğ‘– (1<iâ‰¤n1<ğ‘–â‰¤ğ‘›) is âŒŠi2âŒ‹âŒŠğ‘–2âŒ‹. Thus, all leaves of this tree are at a distance kâˆ’1ğ‘˜âˆ’1 from the root.
â€¡â€¡ A DFS order is found by calling the following dfs function on the given tree.
Note that the DFS order is not unique.
Tags -brute force
Tags -data structures
Tags -dfs and similar
Tags -graphs
Tags -hashing
Tags -trees
Tags -*1900
